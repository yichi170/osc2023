// save general registers to stack
.macro save_all
    sub sp, sp, 34 * 8
    stp x0, x1, [sp ,16 * 0]
    stp x2, x3, [sp ,16 * 1]
    stp x4, x5, [sp ,16 * 2]
    stp x6, x7, [sp ,16 * 3]
    stp x8, x9, [sp ,16 * 4]
    stp x10, x11, [sp ,16 * 5]
    stp x12, x13, [sp ,16 * 6]
    stp x14, x15, [sp ,16 * 7]
    stp x16, x17, [sp ,16 * 8]
    stp x18, x19, [sp ,16 * 9]
    stp x20, x21, [sp ,16 * 10]
    stp x22, x23, [sp ,16 * 11]
    stp x24, x25, [sp ,16 * 12]
    stp x26, x27, [sp ,16 * 13]
    stp x28, x29, [sp ,16 * 14]
    mrs x19, spsr_el1
    mrs x20, elr_el1
    stp x30, x19, [sp, 16 * 15]
    str x20, [sp, 16 * 16]
.endm

// load general registers from stack
.macro load_all
    ldp x19, x20, [sp ,16 * 15 + 8]
    msr spsr_el1, x19
    msr elr_el1, x20
    ldp x0, x1, [sp ,16 * 0]
    ldp x2, x3, [sp ,16 * 1]
    ldp x4, x5, [sp ,16 * 2]
    ldp x6, x7, [sp ,16 * 3]
    ldp x8, x9, [sp ,16 * 4]
    ldp x10, x11, [sp ,16 * 5]
    ldp x12, x13, [sp ,16 * 6]
    ldp x14, x15, [sp ,16 * 7]
    ldp x16, x17, [sp ,16 * 8]
    ldp x18, x19, [sp ,16 * 9]
    ldp x20, x21, [sp ,16 * 10]
    ldp x22, x23, [sp ,16 * 11]
    ldp x24, x25, [sp ,16 * 12]
    ldp x26, x27, [sp ,16 * 13]
    ldp x28, x29, [sp ,16 * 14]
    ldr x30, [sp, 16 * 15]
    add sp, sp, 34 * 8
.endm

invalid_exception_handler:
  save_all
  mov x0, 1
  bl  print_exception
  load_all
  eret

lower_el_sync_exception:
  save_all
  mrs x20, esr_el1
  lsr x19, x20, #26
  sub x19, x19, #0x15 // the exception is caused by svc instruction
  cbz x19, syscall_entry
  load_all
  eret

.extern syscall_table

.globl syscall_entry
syscall_entry:
  adr    x19, syscall_table
  bl     enable_interrupt
  lsl    x20, x8, #3    // multiply x8 by 8 to get the offset in bytes
  add    x19, x19, x20
  ldr    x20, [x19]
  blr    x20            // branch to target syscall function
  str    x0, [sp]
  bl     disable_interrupt
  load_all
  eret

.globl back_to_user_space
back_to_user_space:
  load_all
  eret

el1_irq_exception_handler:
  save_all
  bl c_el1_irq_handler
  load_all
  eret

irq_exception_handler:
  save_all
  bl c_el0_irq_handler
  load_all
  eret

.align 11 // vector table should be aligned to 0x800
.globl exception_vector_table
exception_vector_table:
  b invalid_exception_handler // sync, Current EL with SP0
  .align 7                    // entry size is 0x80, .align will pad 0
  b invalid_exception_handler // irq
  .align 7
  b invalid_exception_handler // fiq
  .align 7
  b invalid_exception_handler // serr
  .align 7

  b invalid_exception_handler // sync, Current EL with SPx
  .align 7
  b el1_irq_exception_handler // irq
  .align 7
  b invalid_exception_handler // fiq
  .align 7
  b invalid_exception_handler // serr
  .align 7

  b lower_el_sync_exception   // sync, Lower EL using AArch64
  .align 7
  b irq_exception_handler     // irq
  .align 7
  b invalid_exception_handler // fiq
  .align 7
  b invalid_exception_handler // serr
  .align 7

  b invalid_exception_handler // sync, Lower EL using AArch32
  .align 7
  b invalid_exception_handler // irq
  .align 7
  b invalid_exception_handler // fiq
  .align 7
  b invalid_exception_handler // serr
  .align 7

.globl set_exception_vector_table
set_exception_vector_table:
  adr x0, exception_vector_table
  msr vbar_el1, x0
  ret